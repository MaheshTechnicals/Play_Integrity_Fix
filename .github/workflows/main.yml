name: Update PIF JSON on New Release

on:
  workflow_dispatch: # Allows manual triggering for the first run
  schedule:
    # Run this workflow every 6 hours to check for new releases
    - cron: '0 */6 * * *'

jobs:
  download_extract_upload:
    runs-on: ubuntu-latest

    steps:
    # Step 1: Check out your repository
    - name: Checkout repository
      uses: actions/checkout@v3

    # Step 2: Restore the cached latest release tag
    - name: Restore latest release tag cache
      id: cache_latest_release
      uses: actions/cache@v3
      with:
        path: latest-release.txt
        key: latest-release-tag

    # Step 3: Get all releases info from PlayIntegrityFix repository
    - name: Get PlayIntegrityFix releases info
      id: get_releases
      run: |
        RELEASE_DATA=$(curl -s https://api.github.com/repos/chiteroman/PlayIntegrityFix/releases)
        LATEST_RELEASE=$(echo "$RELEASE_DATA" | jq -r '.[0].tag_name')
        ALL_RELEASES=$(echo "$RELEASE_DATA" | jq -r '.[].tag_name')
        echo "Latest release tag: $LATEST_RELEASE"
        echo "All releases: $ALL_RELEASES"
        echo "::set-output name=latest_release_tag::$LATEST_RELEASE"
        echo "::set-output name=all_releases::$ALL_RELEASES"

    # Step 4: Compare latest release with cached release tag
    - name: Check if the latest release is new
      id: check_release
      run: |
        if [ -f latest-release.txt ]; then
          CACHED_RELEASE=$(cat latest-release.txt)
          echo "Cached release tag: $CACHED_RELEASE"
        else
          echo "No cached release found. Assuming this is the first run."
          CACHED_RELEASE="none"
        fi

        if [ "$CACHED_RELEASE" != "${{ steps.get_releases.outputs.latest_release_tag }}" ]; then
          echo "New release found: ${{ steps.get_releases.outputs.latest_release_tag }}"
          echo "::set-output name=new_release::true"
        else
          echo "No new release."
          echo "::set-output name=new_release::false"
        fi

    # Step 5: If it's the first run, show all previous releases and download all pif.json files
    - name: Process all previous releases (first run)
      if: steps.check_release.outputs.new_release == 'true' || steps.cache_latest_release.outputs.cache-hit == 'false'
      run: |
        ALL_RELEASES=$(curl -s https://api.github.com/repos/chiteroman/PlayIntegrityFix/releases | jq -r '.[].tag_name')
        for RELEASE_TAG in $ALL_RELEASES; do
          echo "Processing release: $RELEASE_TAG"
          RELEASE_URL=$(curl -s https://api.github.com/repos/chiteroman/PlayIntegrityFix/releases/tags/$RELEASE_TAG | jq -r '.assets[] | select(.name | endswith(".zip")).browser_download_url')
          echo "Downloading $RELEASE_URL"
          curl -L "$RELEASE_URL" --output PlayIntegrityFix-$RELEASE_TAG.zip
          unzip PlayIntegrityFix-$RELEASE_TAG.zip
          if [ -f "pif.json" ]; then
            echo "pif.json found for release $RELEASE_TAG!"
            mv pif.json pif-$RELEASE_TAG.json
          else
            echo "pif.json not found for release $RELEASE_TAG!" && exit 1
          fi
        done

    # Step 6: Generate a valid and unique tag name for your release
    - name: Generate tag name
      id: generate_tag
      run: |
        TAG_NAME="v$(date +'%Y%m%d-%H%M%S')"
        echo "Generated tag name: $TAG_NAME"
        echo "::set-output name=tag::$TAG_NAME"

    # Step 7: Create a new release with all pif.json files (if first run) or only the latest release
    - name: Create new release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.generate_tag.outputs.tag }}  # Use the generated tag
        release_name: "pif.json updates"
        body: |
          Automatically uploaded pif.json files from PlayIntegrityFix repository.
          {{# if steps.cache_latest_release.outputs.cache-hit == 'false' }}
          Previous releases: ${{ steps.get_releases.outputs.all_releases }}.
          {{/ if }}
        draft: false
        prerelease: false

    # Step 8: Upload all pif.json files to the newly created release
    - name: Upload pif.json files to release
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: "./pif-*.json"  # Upload all extracted pif.json files
        asset_name: pif.json
        asset_content_type: application/json

    # Step 9: Cache the latest release tag for future runs
    - name: Cache the latest release tag
      if: steps.check_release.outputs.new_release == 'true' || steps.cache_latest_release.outputs.cache-hit == 'false'
      run: |
        echo "${{ steps.get_releases.outputs.latest_release_tag }}" > latest-release.txt
      uses: actions/upload-artifact@v2
      with:
        name: latest-release-tag
        path: latest-release.txt
